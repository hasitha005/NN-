# mnist_cnn_two_digit.py
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.utils import to_categorical
import cv2
import os

# -------------------------
# 1) Load MNIST dataset (for training)
# -------------------------
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()

# 2) Preprocess: normalize and expand dims for channels
x_train = x_train.astype("float32") / 255.0
x_test  = x_test.astype("float32")  / 255.0
x_train = np.expand_dims(x_train, -1)
x_test  = np.expand_dims(x_test, -1)
y_train_cat = to_categorical(y_train, 10)
y_test_cat  = to_categorical(y_test, 10)

# 3) Build a small CNN (same as before)
def make_model():
    model = models.Sequential([
        layers.Input(shape=(28,28,1)),
        layers.Conv2D(32, (3,3), activation='relu'),
        layers.MaxPooling2D((2,2)),
        layers.Conv2D(64, (3,3), activation='relu'),
        layers.MaxPooling2D((2,2)),
        layers.Flatten(),
        layers.Dense(128, activation='relu'),
        layers.Dropout(0.4),
        layers.Dense(10, activation='softmax')
    ])
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

model = make_model()
model.summary()

# 4) Train
history = model.fit(
    x_train, y_train_cat,
    epochs=3,
    batch_size=128,
    validation_split=0.1,
    verbose=2
)

# 5) Evaluate on test set
test_loss, test_acc = model.evaluate(x_test, y_test_cat, verbose=0)
print(f"Test accuracy: {test_acc:.4f}, Test loss: {test_loss:.4f}")

# 6) Save model
model.save("mnist_cnn.h5")
print("Model saved to mnist_cnn.h5")

# -------------------------
# Utility: preprocessing single 28x28 image for model
# -------------------------
def preprocess_single_gray(img):
    """
    img: grayscale image (numpy array) - arbitrary size
    returns: array shape (1,28,28,1) scaled 0..1 ready for model
    """
    # Ensure it's uint8
    if img.dtype != np.uint8:
        img = (img * 255).astype(np.uint8) if img.max() <= 1.0 else img.astype(np.uint8)

    # If background is white (light), invert to make digit white on black like MNIST
    if img.mean() > 127:
        img = 255 - img

    # Resize to 28x28
    img28 = cv2.resize(img, (28,28), interpolation=cv2.INTER_AREA)

    # Optional: additional thresholding / centering can be added here

    # Normalize
    arr = img28.astype("float32") / 255.0
    arr = np.expand_dims(arr, axis=(0,-1))  # (1,28,28,1)
    return arr

# -------------------------
# Helper: decide split and predict
# -------------------------
def predict_from_image_path(path, model):
    if not os.path.exists(path):
        print("File not found:", path)
        return

    # read grayscale
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        print("Could not read image. Make sure path is correct and image is a readable file.")
        return

    h, w = img.shape
    # Heuristic: if width significantly greater than height, treat as two digits side-by-side
    if w >= int(1.5 * h) and w >= 40:
        # split into two halves (left, right)
        mid = w // 2
        left = img[:, :mid]
        right = img[:, mid:]
        # preprocess both
        a_left = preprocess_single_gray(left)
        a_right = preprocess_single_gray(right)
        X = np.vstack([a_left, a_right])  # shape (2,28,28,1)
        preds = model.predict(X)
        p_labels = np.argmax(preds, axis=1)
        p_conf   = np.max(preds, axis=1)
        print(f"Predicted digits: {p_labels[0]} {p_labels[1]}   Confidences: {p_conf[0]:.3f}, {p_conf[1]:.3f}")
        # show combined image
        combined = np.concatenate([left, right], axis=1)
        plt.imshow(combined, cmap='gray')
        plt.title(f"Pred: {p_labels[0]}{p_labels[1]}  Conf: {p_conf[0]:.2f},{p_conf[1]:.2f}")
        plt.axis('off'); plt.show()
    else:
        # single digit
        arr = preprocess_single_gray(img)
        pred = model.predict(arr)
        label = int(np.argmax(pred))
        conf  = float(np.max(pred))
        print(f"Predicted digit: {label}   Confidence: {conf:.3f}")
        plt.imshow(img, cmap='gray')
        plt.title(f"Predicted: {label} ({conf:.2f})")
        plt.axis('off'); plt.show()

# -------------------------
# Ask user for input path and run prediction
# -------------------------
img_path = input("Enter the image path (example: digit.png or two_digits.png): ").strip()
predict_from_image_path(img_path, model)
